
! subroutine nonlin solves the system of non-linear
! equations generated by the corrector step using
! the modified newton-raphson iteration. it also produces a
! factorized form of the jacobian in the arrays a, tl
! account is taken of the banded structure of the
! jacobian to minimize the number of function evaluations
! required to approximate the derivatives
!

!     n [in] ... size of the non-linear system
!     x1 [inout] ... on entry, the current solution y^(n),
!                    on exit, the new estimated solution, y^(n+1)
!
!     del [in] ... some terms related to the known RHS at time n
!     ijac [inout] ... if equal to 0, re-calculate the Jacobian due to step-size change
!     hjac [inout] ... delta's used for Jacobian estimation via
!                      finite differences, only modified if ijac == 0 on entry

!     x [in] ... the independent variable (or time), passed to deriv
!     h [in] ... the stepsize (gamma*deltat), passed to deriv
!     a, tl, ipiv [inout] ... storage for the jacobian
!     m, m1, m2 [in] ... parameters related to the bandwidth of B
!     emax [in] ... relative tolerance parameter for Newton-Raphson iteration
!
!     ifail [inout] ... error flag
!           = 1, LTRI failed
!           = 2, maximum iterations reached
!           = 3, Newton-Raphson iteration has diverged,
!                a component of the incremental vector exceeds BIG
!
SUBROUTINE NONLIN(X1,N,DEL,IJAC,HJAC,USER_JAC,X,A,TL,LD,IPIV,M,M1,M2,EMAX,&
      H,IFAIL)
   use bode_mod, only: wp, ltri, tsol
   implicit none
   integer, intent(in) :: n, ld, m, m1, m2
   real(wp), intent(inout) :: x1(n)
   real(wp), intent(in) :: del(n)
   integer, intent(inout) :: ijac
   real(wp), intent(inout) :: hjac(n)
   logical, intent(in) :: user_jac
   real(wp), intent(in) :: x, h   ! scalars passed to routine deriv

   ! storage for the factorized Jacobian
   real(wp), intent(inout) :: a(ld,m), tl(ld,m2)
   integer, intent(inout) :: ipiv(n)

   real(wp), intent(in) :: emax
   integer, intent(inout) :: ifail

   external :: pjacb

   real(wp) :: aa(ld,m)

   ! local scratch space, length n is used
   real(wp) :: y(n), f(n), gg(n), v2(n)

   integer :: maxf

   !
   ! if step-size has changed (ijac == 0)
   ! reapproximate the inverse jacobian
   !
   if (ijac == 0) then

      ijac = 1

      if (user_jac) then
         !
         ! exact jacobian callback
         !

         call pjacb(x,x1,n,a,ld,m1,h)

         !print *, "symbolic jacobian"
         !call printarr(n,m1,aa)
      else
         !
         ! approximate Jacobian `a` using finite differences
         !
         call fdjac(n,x1,del,x,h,hjac,a,ld,m1,m,y,f,gg,v2)

         !print *, "numerical jacobian"
         !call printarr(n,m1,a)

         !print *, "difference"
         !call printarr(n,m1,a - aa)
         ! a = aa
      end if
      !stop

      !
      ! obtain LU decomposition of the Jacobian
      !
      call ltri(a,tl,ld,n,ipiv,m,m1,m2,ifail)
      if (ifail /= 0) then
        ! factorization failed
        return
      end if

   end if

   ! maximum number of iterations allowed before non-convergence is assumed
   maxf = n + 10
   call newton_raphson(n,x1,del,a,tl,ipiv,ld,m1,m2,m, &
      maxf,emax,f,gg,v2,ifail)

contains

   subroutine printarr(n,m,A)
      real(wp), intent(in) :: A(:,:)
      integer, intent(in) :: n, m
      integer :: i
      integer :: bw, lb

      do i = 1, n
         lb = (m + 1) - (i-1)
         print '(*(E15.7,:,2X))', a(i,lb:lb+(n-1))
      end do

   end subroutine

   ! Jacobian approximation using finite differences
   subroutine fdjac(n,x1,del,x,h,hjac,a,ld,m1,m,y,f,gg,v2)
      implicit none
      integer, intent(in) :: n, ld, m, m1
      real(wp), intent(in) :: x1(n), del(n)
      real(wp), intent(in) :: x, h ! Scalars pased to deriv
      real(wp), intent(out) :: hjac(n)   ! Step-sizes
      real(wp), intent(inout) :: a(ld,m) ! Banded Jacobian approximation

      ! Scratch arrays
      real(wp), intent(inout) :: y(n), f(n), gg(n), v2(n)

      !
      ! the magnitude of the difference h used in the approximation
      ! of the derivative using-
      !              (f(x+h)-f(x))/h
      ! is   max(hmn,eta*mod(x))
      !
      real(wp), parameter :: hmn = 1.0e-5_wp, eta = 1.0e-4_wp
      integer :: i, j, k, jj, imin, imax, ij

      external :: pmult, deriv

      call pmult(x1,n,y)       ! y := B x1
      call deriv(x1,n,gg,x,h)  ! gg := h*f(x,x1)

      f = y - gg - del
      y = x1

      ! step sizes
      do i = 1, n
         hjac(i) = min(1.0_wp/hmn, max(eta*abs(x1(i)), hmn))
      end do

      ! zero Jacobian array
      a(1:n,1:m) = 0

      !
      ! increment relevant variables - use banded structure
      ! (this uses a graph coloring type approach, to
      !  use only m function evaluations)
      !
      do k = 1, min(m, n)

         ! increment variables by small difference
         do j = k, n, m
            y(j) = x1(j) + hjac(j)
         end do

         ! calculate new vector
         call pmult(y,n,v2)        ! v2 := B (y + hjac)
         call deriv(y,n,gg,x,h)    ! gg := h*f(x,y + hjac)

         ! residual vector
         do i = 1, n
            gg(i) = v2(i) - gg(i) - del(i)
         end do

         ! restore vector
         do j = k, n, m
            y(j) = x1(j)
         end do

         !
         ! approximate derivatives by differencing
         !

         ! Loop over columns of the banded Jacobian
         do j = k, n, m
            jj = m
            imin = -m1
            if (j < (m1+1)) then
               imin = -j + 1
               jj = m1 + j
            end if
            imax = m1
            if (j > (n-m1)) imax = -j + n

            ! Loop over the rows in a column of the Jacobian
            do i = imin, imax
               ij = i + j
               a(ij,jj) = (gg(ij) - f(ij))/hjac(j)
               jj = jj - 1
            end do

         end do
      end do

   end subroutine

   subroutine newton_raphson(n,x1,del,a,tl,ipiv,ld,m1,m2,m,maxf,emax,&
         f,gg,v2,ifail)
      implicit none
      integer, intent(in) :: n, ld, m1, m2, m
      real(wp), intent(inout) :: x1(n)
      real(wp), intent(in) :: del(n)

      ! The factorized Jacobian
      real(wp), intent(in) :: a(ld,m), tl(ld,m2)
      integer, intent(in) :: ipiv(n)

      integer, intent(in) :: maxf
      real(wp), intent(in) :: emax
      ! Scratch space
      real(wp), intent(inout) :: f(n), gg(n), v2(n)

      integer, intent(inout) :: ifail

      !
      ! the modified newton-raphson iteration is assumed to have
      ! diverged if the magnitude of any component of the
      ! incremental vector is greater than big.
      !
      real(wp), parameter :: big = 1.0e10_wp

      external :: pmult, deriv

      logical :: conv
      integer :: it, i

      do it = 1, maxf
         !
         ! do not recalculate f if Jacobian has been reapproximated
         !
         call pmult(x1,n,v2)     ! v2 := B*y
         call deriv(x1,n,gg,x,h)  ! gg := h*f(x,y)
         do i = 1, n
            f(i) = v2(i) - gg(i) - del(i)
         end do

         !
         ! solve for incremental vector, gg := (y_{it+1} - y_{it}) = J^(-1) F(y)
         !
         call tsol(a,tl,ld,m1,m2,m,n,ipiv,f,gg)

         ! increment output vector, while
         ! checking if converged using relative tolerance
         conv = .true.

         do i = 1, n
            if (abs(gg(i)) >= big) then
               ! value exceeds maximum, assume diverging
               ifail = 3
               return
            end if
            x1(i) = x1(i) - gg(i)
            if (abs(gg(i)) > (abs(x1(i)) + 1.0e-6_wp)*emax) conv = .false.
         end do

         ! normal exit, converged
         if (conv) return

      end do

      ! maximum iterations reached
      ifail = 2

   end subroutine

end subroutine


