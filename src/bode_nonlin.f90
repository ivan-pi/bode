!***********************************************************************
! SUBROUTINE NONLIN SOLVES THE SYSTEM OF NON-LINEAR
! EQUATIONS GENERATED BY THE CORRECTOR STEP USING
! THE MODIFIED NEWTON-RAPHSON ITERATION. IT ALSO PRODUCES A 
! FACTORIZED FORM OF THE JACOBIAN IN THE ARRAYS A,TL.
! ACCOUNT IS TAKEN OF THE BANDED STRUCTURE OF THE
! JACOBIAN TO MINIMIZE THE NUMBER OF FUNCTION EVALUATIONS
! REQUIRED TO APPROXIMATE THE DERIVATIVES
!
!     IFAIL = 2, maximum iterations reached
!     IFAIL = 3, Newton-Raphson iteration has diverged,
!                a component of the incremental vector exceeds BIG
!
!***********************************************************************
SUBROUTINE NONLIN(X1,N,DEL,IJAC,HJAC,X,A,TL,INT,M,M1,M2,EMAX,H,IFAIL)
   use bode_mod, only: wp, ld, ltri, tsol
   real(wp), intent(inout) :: x1(n)
   real(wp), intent(in) :: del(n)
   real(wp), intent(inout) :: hjac(n)
   real(wp) :: x   ! passed to routine deriv
   real(wp), intent(inout) :: a(ld,m), tl(ld,m2)
   integer, intent(inout) :: int(n)
   integer, intent(in) :: n, m, m1, m2
   integer, intent(in) :: emax
   integer, intent(inout) :: ijac
   real(wp), intent(in) :: h
   integer, intent(out) :: ifail

   ! local scratch space, length n is used 
   real(wp) :: y(ld), f(ld), gg(ld), v2(ld)  

   !
   ! the magnitude of the difference h used in the approximation
   ! of the derivative usingo-
   !              (f(x+h)-f(x))/h
   ! is   max(hmn,eta*mod(x))
   !
   real(wp), parameter :: hmn = 1.0e-5_wp
   real(wp), parameter :: eta = 1.0e-1_wp
   !
   ! the modified newton-raphson iteration is assumed to have
   ! diverged if the magnitude of any component of the
   ! incremental vector is greater than big.
   !
   real(wp), parameter :: big = 1.0e10_wp

   ! maxf - maximum number of iterations allowed before non-convergence is assumed
   integer :: maxf

   maxf = n + 10

   !
   ! if step-size has been changed reapproximate inverse jacobian
   !
   if (ijac == 0) then

      ijac = 1

      call pmult(x1,n,y)
      call deriv(x1,n,gg,x,h)
      do i = 1, n
         f(i) = y(i) - gg(i) - del(i)
         y(i) = x1(i)
         hjac(i) = min(1.0_wp/hmn, max(eta*abs(x1(i)),hmn))
         do j = 1, m
            a(i,j) = 0.0_wp
         end do
      end do

      !
      ! increment relevant variables - use banded structure
      !

      k = 1
      do while (k < m)
         
         j = k
         do while (j <= n)
            y(j) = x1(j) + hjac(j)
            j = j + m
         end do
         
         call pmult(y,n,v2)
         call deriv(y,n,gg,x,h)
         
         do i = 1, n
            gg(i) = v2(i) - gg(i) - del(i)
         end do
      
         j = k
         do while (j <= n)
            y(j) = x1(j)
            j = j + m
         end do
         
         !
         ! approximate derivatives by differencing
         !
         j = k
         inner: do
            jj = m
            imin = -m1
            if (j < (m1+1)) then
               imin = -j + 1
               jj = m1 + j
            end if

            imax = m1
            if (j > (n-m1)) imax = -j + n
         
            i = imin
            do 
               ij = i + j
               a(ij,jj) = (gg(ij) - f(ij))/hjac(j)
               jj = jj - 1
               i = i + 1
               if (i > imax) exit
            end do         

            j = j + m
            if (j > n) exit

         end do inner
      
         k = k + 1
         if (m > n .and. k > n) exit
      end do

      !
      ! obtain l-u decomposition
      !
      call ltri(a,tl,n,int,m,m1,m2,ifail)
      if (ifail /= 0) then
        ! factorization failed
        return
      end if

   end if

   do it = 1, maxf
      sum1 = 0.0_wp
      iflag = 0

      !
      ! do not recalculate f if  jacobian has been reapproximated
      !
      call pmult(x1,n,v2)
      call deriv(y,n,gg,x,h)
      do i = 1, n 
         f(i) = v2(i) - gg(i) - del(i)
      end do

      !
      ! solve for incremental vector
      !
      call tsol(a,tl,m1,m2,m,n,int,f,gg)
      do i = 1, n
         ggi = gg(i)
         if (abs(ggi) >= big) then
            ifail = 3
            return
         end if
         x1(i) = x1(i) - ggi
         if (abs(ggi) > (abs(x1(i)) + 1.0e-6_wp)*emax) iflag = 1
      end do
      
      if (iflag == 0) return ! normal exit

   end do

   ifail = 2 ! maximum iterations reachesd

end subroutine