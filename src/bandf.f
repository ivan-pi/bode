c     ---------------------------------------------------
c     This file is auto-generated by Fypp.
c     Please do not edit this file directly.
c     ---------------------------------------------------

c     ---------------------------------------------------
c     Subroutine sbandf -- Partial pivoting version
c
c     This subroutine performs an LU decomposition on a
c     banded matrix A. A is overwritten with L,U. L is
c     the unit lower triangular. U is upper triangular.
c     A(i,j) <-- U(i,j) for j .gt. i
c     A(i,i) <-- Inverse of U(i,i)
c     A(i,j) <-- L(i,j) for j .lt. i
c     (The unit diagonal of L is implicit.)
c     The accompanying subroutine 'sbands' uses the
c     output of this routine to solve for a particular
c     right-hand side.
c
c     Storage:
c     The diagonals of A (and L,U) are stored in the
c     input array a(n,m) where n is the dimension of
c     the system and m is the bandwidth. m must be odd.
c     The columns of a(n,m) are assumed to be symmetri-
c     cally placed about the central diagonal of A. The
c     relation between elemens of 'A' and 'a' is:
c              A(i,j) = a(i,j-i+(m+1)/2).
c
c     Pivoting:
c     Pivots are selected from the column below the
c     current diagonal element. Row interchange infor-
c     mation is stored in the integer vector p(n),
c     which is used by subroutine sbands'. The
c     horizonal dimension of 'a' must be at least
c     m + (m-1)/2 : the extra (m-1)/2 superdiagonals
c     of A provide space for the interchanged rows. On
c     normal exit, ifail is zero. If a very small pivot
c     is encountered, ifail > 0, or ifail
c     zero. Small pivots indicate a near singular matrix.
c     ---------------------------------------------------
      subroutine sbandf(a,m,n,p,ifail)
      integer, parameter :: rk = kind(1.0e0)
      integer, intent(in) :: m, n
      real(kind=rk), intent(inout) :: a(n,*)
      integer, intent(out) :: p(n)
      integer, intent(out) :: ifail

      real(kind=rk), parameter :: zero = 0
      real(kind=rk), parameter :: one = 1
      real(kind=rk), parameter :: eps = epsilon(a)

      intrinsic :: abs

      integer :: g, h, i, j, k, r
      real(kind=rk) :: c, max, d

      ifail = 0
      r = (m+1)/2
      do 10 i = 1,n
      do 11 j = m+1,m+r-1
         a(i,j) = zero
   11 continue
   10 continue

      do 20 k = 1,n
c
c     Find pivots
c
         max = zero
         i = k
         j = r
   25    if (i.gt.n .or. j.lt.1) goto 30
         d = abs(a(i,j))
         if (max.ge.d) goto 35
         max = d
         p(k) = i
   35    i = i+1
         j = j-1
         goto 25
   30    continue
         if(max.le.eps) goto 99
c
c     Switch pivot rows
c
         if (p(k).eq.k) goto 40
         i = r
         j = r+k-p(k)
   50    if (i.gt.m+r-1 .or. i.gt.n-k+r) goto 40
         c = a(k,i)
         a(k,i) = a(p(k),j)
         a(p(k),j) = c
         i = i+1
         j = j+1
         goto 50
   40    continue
c
c     Decompose A
c
         a(k,r) = one/a(k,r)
         h = r-1
         i=k+1
   60    if (h.lt.1 .or. i.gt.n) goto 20
         a(i,h) = a(i,h) * a(k,r)
         j = h+1
         g = r+1
   70    if (g.gt.m+r-1 .or. j.gt.n+r-i) goto 80
         a(i,j) = a(i,j) - a(i,h)*a(k,g)
         j = j+1
         g = g+1
         goto 70
   80    continue
         i = i+1
         h = h-1
         goto 60
   20 continue
      return
c
c     the matrix is singular
c
   99 ifail = k
      return
      end
c     ---------------------------------------------------
c     Subroutine dbandf -- Partial pivoting version
c
c     This subroutine performs an LU decomposition on a
c     banded matrix A. A is overwritten with L,U. L is
c     the unit lower triangular. U is upper triangular.
c     A(i,j) <-- U(i,j) for j .gt. i
c     A(i,i) <-- Inverse of U(i,i)
c     A(i,j) <-- L(i,j) for j .lt. i
c     (The unit diagonal of L is implicit.)
c     The accompanying subroutine 'dbands' uses the
c     output of this routine to solve for a particular
c     right-hand side.
c
c     Storage:
c     The diagonals of A (and L,U) are stored in the
c     input array a(n,m) where n is the dimension of
c     the system and m is the bandwidth. m must be odd.
c     The columns of a(n,m) are assumed to be symmetri-
c     cally placed about the central diagonal of A. The
c     relation between elemens of 'A' and 'a' is:
c              A(i,j) = a(i,j-i+(m+1)/2).
c
c     Pivoting:
c     Pivots are selected from the column below the
c     current diagonal element. Row interchange infor-
c     mation is stored in the integer vector p(n),
c     which is used by subroutine dbands'. The
c     horizonal dimension of 'a' must be at least
c     m + (m-1)/2 : the extra (m-1)/2 superdiagonals
c     of A provide space for the interchanged rows. On
c     normal exit, ifail is zero. If a very small pivot
c     is encountered, ifail > 0, or ifail
c     zero. Small pivots indicate a near singular matrix.
c     ---------------------------------------------------
      subroutine dbandf(a,m,n,p,ifail)
      integer, parameter :: rk = kind(1.0d0)
      integer, intent(in) :: m, n
      real(kind=rk), intent(inout) :: a(n,*)
      integer, intent(out) :: p(n)
      integer, intent(out) :: ifail

      real(kind=rk), parameter :: zero = 0
      real(kind=rk), parameter :: one = 1
      real(kind=rk), parameter :: eps = epsilon(a)

      intrinsic :: abs

      integer :: g, h, i, j, k, r
      real(kind=rk) :: c, max, d

      ifail = 0
      r = (m+1)/2
      do 10 i = 1,n
      do 11 j = m+1,m+r-1
         a(i,j) = zero
   11 continue
   10 continue

      do 20 k = 1,n
c
c     Find pivots
c
         max = zero
         i = k
         j = r
   25    if (i.gt.n .or. j.lt.1) goto 30
         d = abs(a(i,j))
         if (max.ge.d) goto 35
         max = d
         p(k) = i
   35    i = i+1
         j = j-1
         goto 25
   30    continue
         if(max.le.eps) goto 99
c
c     Switch pivot rows
c
         if (p(k).eq.k) goto 40
         i = r
         j = r+k-p(k)
   50    if (i.gt.m+r-1 .or. i.gt.n-k+r) goto 40
         c = a(k,i)
         a(k,i) = a(p(k),j)
         a(p(k),j) = c
         i = i+1
         j = j+1
         goto 50
   40    continue
c
c     Decompose A
c
         a(k,r) = one/a(k,r)
         h = r-1
         i=k+1
   60    if (h.lt.1 .or. i.gt.n) goto 20
         a(i,h) = a(i,h) * a(k,r)
         j = h+1
         g = r+1
   70    if (g.gt.m+r-1 .or. j.gt.n+r-i) goto 80
         a(i,j) = a(i,j) - a(i,h)*a(k,g)
         j = j+1
         g = g+1
         goto 70
   80    continue
         i = i+1
         h = h-1
         goto 60
   20 continue
      return
c
c     the matrix is singular
c
   99 ifail = k
      return
      end
