C***********************************************************************
C SUBROUTINE NONLIN SOLVES THE SYSTEM OF NON-LINEAR
C EQUATIONS GENERATED BY THE CORRECTOR STEP USING
C THE MODIFIED NEWTON-RAPHSON ITERATION. IT ALSO PRODUCES A 
C FACTORIZED FORM OF THE JACOBIAN IN THE ARRAYS A,TL.
C ACCOUNT IS TAKEN OF THE BANDED STRUCTURE OF THE
C JACOBIAN TO MINIMIZE THE NUMBER OF FUNCTION EVALUATIONS
C REQUIRED TO APPROXIMATE THE DERIVATIVES
C
C     IFAIL = 2, maximum iterations reached
C     IFAIL = 3, Newton-Raphson iteration has diverged,
C                a component of the incremental vector exceeds BIG
C
C***********************************************************************
      SUBROUTINE NONLIN(X1,N,DEL,IJAC,HJAC,X,A,TL,INT,M,M1,M2,EMAX,
     *  H,IFAIL)
      real, intent(inout) :: x1(n)
      real, intent(in) :: del(n)
      real, intent(inout) :: hjac(n)
      real :: x   ! passed to routine deriv
      real, intent(inout) :: a(75,m), tl(75,m2)
      integer, intent(inout) :: int(n)
      integer, intent(in) :: n, m, m1, m2
      integer, intent(in) :: emax
      integer, intent(inout) :: ijac
      real, intent(in) :: h
      integer, intent(out) :: ifail


      real :: y(75), f(75), gg(75), v2(75)  ! local scratch space, length n is used 

      real, parameter :: hmn = 1.0e-5
      real, parameter :: eta = 1.0e-1
C***********************************************************************
C DATA STATEMENT
C --------------
C
C THE MAGNITUDE OF THE DIFFERENCE H USED IN THE APPROXIMATION
C OF THE DERIVATIVE USINGO-
C              (F(X+H)-F(X))/H
C IS   MAX(HMN,ETA*MOD(X))
C
C THE MODIFIED NEWTON-RAPHSON ITERATION IS ASSUMED TO HAVE
C DIVERGED IF THE MAGNITUE OF ANY COMPONENT OF THE
C INCREMENTAL VECTOR IS GREATER THAN BIG.
C***********************************************************************
      real, parameter :: big = 1.0e10
C***********************************************************************
C MAXF - MAXIMUM NUMBER OF ITERATIONS ALLOWED BEFORE NON-
C        CONVERGENCE IS ASSUMED
C***********************************************************************
      integer :: maxf

      maxf = n + 10

C***********************************************************************
C IF STEP-SIZE HAS BEEN CHANGED REAPPROXIMATE INVERSE JACOBIAN
C***********************************************************************
      if (ijac == 1) go to 120

      call pmult(x1,n,y)
      call deriv(x1,n,gg,x,h)
      do i = 1, n
         f(i) = y(i) - gg(i) - del(i)
         y(i) = x1(i)
         hjac(i) = min(1.0/hmn, max(eta*abs(x1(i)),hmn))
         do j = 1, m
            a(i,j) = 0.0
         end do
      end do
      k = 1
C***********************************************************************
C INCREMENT RELEVANT VARIABLES - USE BANDED STRUCTURE
C***********************************************************************
      do while (k < m)
      J = K
   30 IF (J.GT.N) GO TO 40
      Y(J)=X1(J)+HJAC(J)
      J=J+M
      GO TO 30
   40 call pmult(y,n,v2)
      call deriv(y,n,gg,x,h)
      do i=1,n
         gg(i) = v2(i) - gg(i) - del(i)
      end do
      J=K
   60 IF (J.GT.N) GO TO 70 
      Y(J)=X1(J)
      J=J+M
      GO TO 60
   70 J=K
C***********************************************************************
C APPROXIMATE DERIVATIVES BY DIFFERENCING
C***********************************************************************
   80 JJ=M
      IMIN=-M1
      IF (J < (M1+1))
         IMIN=-J+1
         JJ=M1+J
      end if
      IMAX=M1
      IF (J.GT.(N-M1)) IMAX=-J+N
      I=IMIN


      do while (i <= imax)
         ij = i + j
         a(ij,jj) = (gg(ij) - f(ij))/hjac(j)
         jj = jj - 1
         i = i + 1
      end do         

  100 IJ=I+J
      A(IJ,JJ)=(GG(IJ)-F(IJ))/HJAC(J)
      JJ=JJ-1
      I=I+1
      IF (I.LE.IMAX) GO TO 100
      J=J+M
      IF (J.LE.N) GO TO 80
      
         k = k + 1
         if (m > n .and. k > n) exit
      end do

  110 CONTINUE

C***********************************************************************
C OBTAIN L-U DECOMPOSITION
C***********************************************************************
      call ltri(a,tl,n,int,m,m1,m2,ifail)
      if (ifail /= 0) then
        ! factorization failed
        return
      end if
      if (ijac >= 0) ijac=1

  120 do it = 1, maxf
          sum1 = 0.0
          iflag = 0

c***********************************************************************
c do not recalculate f if  jacobian has been reapproximated
c***********************************************************************
          call pmult(x1,n,v2)
          call deriv(y,n,gg,x,h)
          do i = 1, n 
            f(i) = v2(i) - gg(i) - del(i)
          end do

c***********************************************************************
c solve for incremental vector
c***********************************************************************
          call tsol(a,tl,m1,m2,m,n,int,f,gg)
          do i = 1, n
            ggi = gg(i)
            if (abs(ggi) >= big) then
               ifail = 3
               return
            end if
            x1(i) = x1(i) - ggi
            if (abs(ggi) > (abs(x1(i)) + 1.e-6)*emax) iflag = 1
          end do
          if (iflag == 0) return ! normal exit
      end do

      IFAIL = 2 ! maximum iterations reachesd

      end subroutine